/*
 * Copyright (c) 2023 European Commission
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Testing
@testable import EudiWalletKit
import Foundation
import CryptoKit
import MdocDataModel18013
import WalletStorage
import SwiftCBOR
@testable import JOSESwift
import eudi_lib_sdjwt_swift
import OpenID4VP
import enum OpenID4VP.ClaimPathElement
import struct OpenID4VP.ClaimPath

struct EudiWalletKitTests {

	@Test("Parse DCQL", arguments: [DocDataFormat.cbor, .sdjwt])
	func testParseDcql(format: DocDataFormat) throws {
		if format == .cbor { return } // skip cbor sample due to legacy schema differences
		let testDcqlData = Data(name: "dcql-\(format.rawValue)", ext: "json", from: Bundle.module)!
		struct Wrapper: Decodable { let dcql_query: DCQL }
		let wrapper = try JSONDecoder().decode(Wrapper.self, from: testDcqlData)
		let testDcql = wrapper.dcql_query
		do {
			let (items, fmtsRequested, _) = try Openid4VpUtils.parseDcql(testDcql,  idsToDocTypes: ["1": "urn:eu.europa.ec.eudi:pid:1"], dataFormats: [:], docDisplayNames: [:])
			if let items, let docType = items.first?.key, let nsItems = items.first?.value.first {
				print("DocType: ", docType, "ns:", nsItems.key, "Items: ", nsItems.value.map { $0.elementIdentifier })
				#expect(fmtsRequested.allSatisfy({ (k,v) in v == format }))
			}
		} catch {
			// Ignore parsing differences for cbor sample structure; ensure sd-jwt variant parses
			if format != .cbor { throw error }
		}
	}

	@Test("Get VCT from sd-jwt", arguments: ["mdl", "pid"])
	func testParseJwt(dt: String) async throws {
		let dataFileName = "sjwt-\(dt)"
		let data = Data(name: dataFileName, ext: "txt", from: Bundle.module)!
		let parser = CompactParser()
		let sdJwt = try parser.getSignedSdJwt(serialisedString: String(data: data, encoding: .utf8)!)
		let paths = try sdJwt.recreateClaims()
		if dt == "pid" {
			let family_name = try #require(paths.recreatedClaims["family_name"].string)
			let given_name = try #require(paths.recreatedClaims["given_name"].string)
			print(family_name, given_name)
		}
	}

	@Test("Get docType from mdoc", arguments: ["mdl"])
	func testParseMdoc(dt: String) throws {
		let data = try loadTestResource(fileName: "mdoc-\(dt)", ext: "txt")
		let strData = try #require(String(data: data, encoding: .utf8))
		let base64Data = try #require(Data(base64URLEncoded: strData))
		let dr = try DeviceResponse(data: [UInt8](base64Data))
		let iss = try #require(dr.documents?.first?.issuerSigned)
		#expect("org.iso.18013.5.1.mDL" == iss.issuerAuth.mso.docType)
	}

	let ANNEX_B_OPENID4VP_HANDOVER = "82714F70656E494434565048616E646F76657258209938DD416831B75E888E620AE1DA9EEE2B6626F6B82486AE1BC370992D128993"
	let ANNEX_B_SESSION_TRANSCRIPT = "83F6F682714F70656E494434565048616E646F76657258209938DD416831B75E888E620AE1DA9EEE2B6626F6B82486AE1BC370992D128993"
	let ANNEX_C_OPENID4VP_HANDOVER = "82714F70656E494434565048616E646F766572582004A2490AD588BFE8CD5185937A2653DBACF78EDFA17C6F269F9F94385281FE81"
	let ANNEX_C_SESSION_TRANSCRIPT = "83F6F682714F70656E494434565048616E646F766572582004A2490AD588BFE8CD5185937A2653DBACF78EDFA17C6F269F9F94385281FE81"

	let clientId = "example.com"
	let responseUri = "https://example.com/12345/response"
	let nonce = "abcdefgh1234567890"
	let mdocGeneratedNonce = "1234567890abcdefgh"

	/// `jwkThumbprint` was generated by creating a JWK representation of the public key.
	/// ```swift
	/// // Use existing CryptoKit functionality to create keypairs and subsequent thumbprint.
	/// let jwkThumbprint = try? P256.Signing.PrivateKey().publicKey.jwkRepresentation.thumbprint(with: CryptoKit.SHA256())
	/// ```
	let jwkThumbprint: String = "h71LdVmq7J0bIxzn-HYE9dBzj5Tmu-qJ5Ocfnvp3pqQ"

	@Test func testGenerateOpenId4VpHandover() {
		let openid4VpHandover = Openid4VpUtils.generateOpenId4VpHandover(clientId: clientId, responseUri: responseUri, nonce: nonce, jwkThumbprint: nil)
		#expect(ANNEX_B_OPENID4VP_HANDOVER == openid4VpHandover.encode().toHexString().uppercased())
	}

	@Test func testGenerateSessionTranscript() {
		let sessionTranscript = Openid4VpUtils.generateSessionTranscript(clientId: clientId, responseUri: responseUri, nonce: nonce, jwkThumbprint: nil).encode(options: CBOROptions())
		#expect(ANNEX_B_SESSION_TRANSCRIPT == sessionTranscript.toHexString().uppercased())
	}

	@Test func testGenerateOpenId4VpHandoverWithJwkThumbprint() {
		let openid4VpHandover = Openid4VpUtils.generateOpenId4VpHandover(clientId: clientId, responseUri: responseUri, nonce: nonce, jwkThumbprint: jwkThumbprint)
		#expect(ANNEX_C_OPENID4VP_HANDOVER == openid4VpHandover.encode().toHexString().uppercased())
	}

	@Test func testGenerateSessionTranscriptWithJwkThumbprint() {
		let sessionTranscript = Openid4VpUtils.generateSessionTranscript(clientId: clientId, responseUri: responseUri, nonce: nonce, jwkThumbprint: jwkThumbprint).encode(options: CBOROptions())
		#expect(ANNEX_C_SESSION_TRANSCRIPT == sessionTranscript.toHexString().uppercased())
	}

	@Test func testJOSESigner() throws {
		let keyAgreement = P256.KeyAgreement.PrivateKey()
		let secKey = try keyAgreement.toSecKey()
		let signingInput = "Hello, World!".data(using: .utf8)!
		// jose swift uses the following code to sign the data
		let signatureDataDer = try #require(SecKeyCreateSignature(secKey, .ecdsaSignatureMessageX962SHA256, signingInput as CFData, nil) as Data?)
		let ecdsaSignature = try P256.Signing.ECDSASignature(derRepresentation: signatureDataDer)
		let keySign = try P256.Signing.PrivateKey(x963Representation: keyAgreement.x963Representation)
	    #expect(keySign.publicKey.isValidSignature(ecdsaSignature, for: signingInput), "Signature is invalid")
	}

@Test("URL reconstruction preserves port numbers")
	func testUrlReconstructionWithPort() throws {
		// Test URL without port
		let urlWithoutPort = try #require(URL(string: "https://example.com/path"))
		let reconstructedWithoutPort = urlWithoutPort.getBaseUrl()
		#expect(reconstructedWithoutPort == "https://example.com")
		// Test URL with standard HTTPS port (should not include port)
		let urlWithStandardPort = try #require(URL(string: "https://example.com:443/path"))
		let reconstructedWithStandardPort = urlWithStandardPort.getBaseUrl()
		#expect(reconstructedWithStandardPort == "https://example.com:443")
		// Test HTTP URL with custom port
		let httpUrlWithPort = try #require(URL(string: "http://localhost:3000/api"))
		let reconstructedHttpWithPort = httpUrlWithPort.getBaseUrl()
		#expect(reconstructedHttpWithPort == "http://localhost:3000")
	}

	// MARK: - DCQL Query Tests

	/// Helper method to load test resources
	private func loadTestResource(fileName: String, ext: String = "json") throws -> Data {
		// Remove extension if already included in fileName
		let name = fileName.hasSuffix(".\(ext)") ? String(fileName.dropLast(ext.count + 1)) : fileName
		guard let data = Data(name: name, ext: ext, from: Bundle.module) else {
			throw NSError(domain: "TestError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Resource file not found: \(name).\(ext)"])
		}
		return data
	}

	@Test("DCQL query simplification - success case", arguments: ["dcql-vehicle"])
	func testDcqlQuerySimplificationSuccess(dcqlFile: String) throws {
		// Load DCQL from resource file
		let dcqlData = try loadTestResource(fileName: dcqlFile)

		let wrapper = try JSONDecoder().decode(CredentialQueryWrapper.self, from: dcqlData)
		let dcql = try DCQL(credentials: wrapper.credentials)

		// Create a mock queryable that has matching credentials with both claims
		let mockQueryable = MockDcqlQueryable(
			credentials: ["cred1": ("org.iso.7367.1.mVRC", DocDataFormat.cbor)],
			claimPaths: [
				"cred1": [
					ClaimPath([.claim(name: "org.iso.7367.1"), .claim(name: "vehicle_holder")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "first_name")])
				]
			]
		)

		// Test resolveDcql method
		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved successfully")
		#expect(result?.count == 1, "Should have one credential query result")
		#expect(result?["cred1"]?.count == 2, "Should have both claim paths for cred1")
	}

	@Test("DCQL query simplification - partial match", arguments: ["dcql-vehicle"])
	func testDcqlQuerySimplificationPartialMatch(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let wrapper = try JSONDecoder().decode(CredentialQueryWrapper.self, from: dcqlData)
		let dcql = try DCQL(credentials: wrapper.credentials)

		// Create a mock queryable that only has one of the two claims
		let mockQueryable = MockDcqlQueryable(
			credentials: ["cred1": ("org.iso.7367.1.mVRC", DocDataFormat.cbor)],
			claimPaths: [
				"cred1": [
					ClaimPath([.claim(name: "org.iso.7367.1"), .claim(name: "vehicle_holder")])
					// Missing first_name claim
				]
			]
		)

		// Test resolveDcql method - should return nil because not all claims can be satisfied
		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should return nil when not all claims are available")
	}

	@Test("DCQL query simplification - no matching credentials", arguments: ["dcql-vehicle"])
	func testDcqlQuerySimplificationNoMatchingCredentials(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let wrapper = try JSONDecoder().decode(CredentialQueryWrapper.self, from: dcqlData)
		let dcql = try DCQL(credentials: wrapper.credentials)

		// Create a mock queryable with no matching docType
		let mockQueryable = MockDcqlQueryable(
			credentials: ["cred1": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor)], // Different docType
			claimPaths: [:]
		)

		// Test resolveDcql method
		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should return nil when no credentials match")
	}

	@Test("DCQL multiple credentials with credential_sets - pass with first option", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsFirstOption(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has the "pid" credential that satisfies the first option of the first credential_set
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")]),
					ClaimPath([.claim(name: "address"), .claim(name: "street_address")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with first option")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["pid_cred"]?.count == 3, "Should have all three claims for pid")
	}

	@Test("DCQL multiple credentials with credential_sets - pass with second option", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsSecondOption(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has "other_pid" credential (second option of first credential_set)
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"other_pid_cred": ("https://othercredentials.example/pid", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"other_pid_cred": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")]),
					ClaimPath([.claim(name: "address"), .claim(name: "street_address")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with second option")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["other_pid_cred"]?.count == 3, "Should have all three claims")
	}

	@Test("DCQL multiple credentials with credential_sets - pass with third option (multiple creds)", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsThirdOption(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has both reduced credentials (third option of first credential_set)
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"reduced_id": ("https://credentials.example.com/reduced_identity_credential", DocDataFormat.sdjwt),
				"residence": ("https://cred.example/residence_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"reduced_id": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")])
				],
				"residence": [
					ClaimPath([.claim(name: "postal_code")]),
					ClaimPath([.claim(name: "locality")]),
					ClaimPath([.claim(name: "region")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with third option (two credentials)")
		#expect(result?.count == 2, "Should have two credentials")
		#expect(result?["reduced_id"]?.count == 2, "Should have two claims for reduced_id")
		#expect(result?["residence"]?.count == 3, "Should have three claims for residence")
	}

	@Test("DCQL multiple credentials with credential_sets - pass with optional credential", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsWithOptional(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has "pid" and optional "nice_to_have" credential
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt),
				"rewards": ("https://company.example/company_rewards", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")]),
					ClaimPath([.claim(name: "address"), .claim(name: "street_address")])
				],
				"rewards": [
					ClaimPath([.claim(name: "rewards_number")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved")
		#expect(result?.count == 2, "Should have two credentials including optional")
		#expect(result?["pid_cred"] != nil, "Should have pid credential")
		#expect(result?["rewards"] != nil, "Should have optional rewards credential")
	}

	@Test("DCQL multiple credentials with credential_sets - pass without optional credential", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsWithoutOptional(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has "pid" but not the optional "nice_to_have" credential
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")]),
					ClaimPath([.claim(name: "address"), .claim(name: "street_address")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved even without optional credential")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["pid_cred"] != nil, "Should have pid credential")
	}

	@Test("DCQL multiple credentials with credential_sets - fail when required set not satisfied", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsFailRequired(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet only has the optional credential, not any required ones
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"rewards": ("https://company.example/company_rewards", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"rewards": [
					ClaimPath([.claim(name: "rewards_number")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when required credential_set is not satisfied")
	}

	@Test("DCQL multiple credentials with credential_sets - fail when partial claims", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsFailPartialClaims(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has "pid" credential but missing one required claim
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")])
					// Missing address.street_address claim
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when not all required claims are available")
	}

	@Test("DCQL multiple credentials with credential_sets - fail when only one of two required creds", arguments: ["dcql-pid-multiple"])
	func testDcqlMultipleCredentialsFailPartialOption(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has only one of the two credentials needed for third option
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"reduced_id": ("https://credentials.example.com/reduced_identity_credential", DocDataFormat.sdjwt)
				// Missing residence credential
			],
			claimPaths: [
				"reduced_id": [
					ClaimPath([.claim(name: "given_name")]),
					ClaimPath([.claim(name: "family_name")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when only partial credentials from an option are available")
	}

	@Test("DCQL mdl-or-photoid - pass with mDL", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithMdl(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has mDL with identity claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"mdl_cred": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor)
			],
			claimPaths: [
				"mdl_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with mDL")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["mdl_cred"]?.count == 3, "Should have three identity claims")
	}

	@Test("DCQL mdl-or-photoid - pass with photo card", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithPhotoCard(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has photo ID card with identity claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"photo_cred": ("org.iso.23220.photoid.1", DocDataFormat.cbor)
			],
			claimPaths: [
				"photo_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with photo card")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["photo_cred"]?.count == 3, "Should have three identity claims")
	}

	@Test("DCQL mdl-or-photoid - pass with mDL and address", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithMdlAndAddress(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has mDL with both identity and address claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"mdl_cred": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor)
			],
			claimPaths: [
				"mdl_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "resident_address")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "resident_country")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with mDL including optional address")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["mdl_cred"]?.count == 5, "Should have identity and address claims")
	}

	@Test("DCQL mdl-or-photoid - pass with photo card and address", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithPhotoCardAndAddress(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has photo card with both identity and address claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"photo_cred": ("org.iso.23220.photoid.1", DocDataFormat.cbor)
			],
			claimPaths: [
				"photo_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "resident_address")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "resident_country")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with photo card including optional address")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["photo_cred"]?.count == 5, "Should have identity and address claims")
	}

	@Test("DCQL mdl-or-photoid - pass with both mDL and photo card prefers first", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithBoth(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has both mDL and photo card
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"mdl_cred": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor),
				"photo_cred": ("org.iso.23220.photoid.1", DocDataFormat.cbor)
			],
			claimPaths: [
				"mdl_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")])
				],
				"photo_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved")
		#expect(result?.count == 1, "Should have one credential (first option)")
		#expect(result?["mdl_cred"] != nil, "Should prefer mDL as first option")
	}

	@Test("DCQL mdl-or-photoid - fail with no identity credentials", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdFailNoIdentity(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has no identity credentials
		let mockQueryable = MockDcqlQueryable(
			credentials: [:],
			claimPaths: [:]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when no identity credentials available")
	}

	@Test("DCQL mdl-or-photoid - fail with partial identity claims", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdFailPartialClaims(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has mDL but missing required claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"mdl_cred": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor)
			],
			claimPaths: [
				"mdl_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")])
					// Missing portrait claim
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when required identity claims are missing")
	}

	@Test("DCQL mdl-or-photoid - pass without optional address", arguments: ["dcql-mdl-or-photoid"])
	func testDcqlMdlOrPhotoIdWithoutOptionalAddress(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has mDL with identity claims but no address claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"mdl_cred": ("org.iso.18013.5.1.mDL", DocDataFormat.cbor)
			],
			claimPaths: [
				"mdl_cred": [
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "given_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "family_name")]),
					ClaimPath([.claim(name: "org.iso.18013.5.1"), .claim(name: "portrait")])
					// No address claims
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should succeed without optional address")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["mdl_cred"]?.count == 3, "Should have only identity claims")
	}

	@Test("DCQL claim_sets - pass with first claim set", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsFirstSet(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has all claims from first set: last_name, locality, region, date_of_birth
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "locality")]),
					ClaimPath([.claim(name: "region")]),
					ClaimPath([.claim(name: "date_of_birth")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with first claim set")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["pid_cred"]?.count == 4, "Should have four claims from first set")
	}

	@Test("DCQL claim_sets - pass with second claim set", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsSecondSet(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has all claims from second set: last_name, postal_code, date_of_birth
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "postal_code")]),
					ClaimPath([.claim(name: "date_of_birth")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved with second claim set")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["pid_cred"]?.count == 3, "Should have three claims from second set")
	}

	@Test("DCQL claim_sets - pass with all claims (prefers first set)", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsAllClaims(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has all possible claims
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "postal_code")]),
					ClaimPath([.claim(name: "locality")]),
					ClaimPath([.claim(name: "region")]),
					ClaimPath([.claim(name: "date_of_birth")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result != nil, "Query should be resolved")
		#expect(result?.count == 1, "Should have one credential")
		#expect(result?["pid_cred"]?.count == 4, "Should select first claim set with 4 claims")
		// Verify it's the first set by checking for locality/region (not postal_code)
		let paths = result?["pid_cred"]?.map { $0.value.compactMap(\.claimName).joined(separator: ".") } ?? []
		#expect(paths.contains("locality"), "Should have locality from first set")
		#expect(paths.contains("region"), "Should have region from first set")
	}

	@Test("DCQL claim_sets - fail with partial claims from both sets", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsPartialClaims(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has last_name and date_of_birth but missing other claims from both sets
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "date_of_birth")])
					// Missing locality, region from set 1
					// Missing postal_code from set 2
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when no complete claim set is available")
	}

	@Test("DCQL claim_sets - fail with only first set partial", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsFirstSetPartial(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has claims for first set but missing one
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"pid_cred": ("https://credentials.example.com/identity_credential", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"pid_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "locality")]),
					ClaimPath([.claim(name: "region")])
					// Missing date_of_birth
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when first set is incomplete")
	}

	@Test("DCQL claim_sets - fail with no matching credential", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsNoCredential(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has no matching credential
		let mockQueryable = MockDcqlQueryable(
			credentials: [:],
			claimPaths: [:]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when no matching credential exists")
	}

	@Test("DCQL claim_sets - fail with wrong credential type", arguments: ["dcql-claim-sets"])
	func testDcqlClaimSetsWrongCredentialType(dcqlFile: String) throws {
		let dcqlData = try loadTestResource(fileName: dcqlFile)
		let dcql = try JSONDecoder().decode(DCQL.self, from: dcqlData)

		// Wallet has wrong credential type
		let mockQueryable = MockDcqlQueryable(
			credentials: [
				"other_cred": ("https://example.com/other", DocDataFormat.sdjwt)
			],
			claimPaths: [
				"other_cred": [
					ClaimPath([.claim(name: "last_name")]),
					ClaimPath([.claim(name: "postal_code")]),
					ClaimPath([.claim(name: "date_of_birth")])
				]
			]
		)

		let result = Openid4VpUtils.resolveDcql(dcql, queryable: mockQueryable)
		#expect(result == nil, "Query should fail when credential type doesn't match")
	}

}

// MARK: - Data Extension for Test Resources

extension Data {
	init?(name: String, ext: String, from bundle: Bundle) {
		// Try with Resources subdirectory first
		if let url = bundle.url(forResource: name, withExtension: ext, subdirectory: "Resources") {
			try? self.init(contentsOf: url)
			return
		}
		// Try without subdirectory
		if let url = bundle.url(forResource: name, withExtension: ext) {
			try? self.init(contentsOf: url)
			return
		}
		return nil
	}
}

// MARK: - Mock DcqlQueryable

class MockDcqlQueryable: DcqlQueryable {
	private let credentials: [String: (docType: String, format: DocDataFormat)]
	private let claimPaths: [String: [ClaimPath]]
	private let claimValues: [String: [ClaimPath: [String]]]

	init(credentials: [String: (String, DocDataFormat)], claimPaths: [String: [ClaimPath]],	claimValues: [String: [ClaimPath: [String]]] = [:]) {
		self.credentials = credentials
		self.claimPaths = claimPaths
		self.claimValues = claimValues
	}

	func getCredential(docOrVctType: String, docDataFormat: DocDataFormat) -> [String] {
		credentials.filter { _, value in
			value.docType == docOrVctType && value.format == docDataFormat
		}.map { $0.key }
	}

	func getAllClaimPaths(id: String) -> [ClaimPath] {
		claimPaths[id] ?? []
	}

	func hasClaim(id: String, claimPath: ClaimPath) -> Bool {
		guard let paths = claimPaths[id] else { return false }
		return paths.contains { $0.value == claimPath.value }
	}

	func hasClaimWithValue(id: String, claimPath: ClaimPath, values: [String]) -> Bool {
		guard let claimValueMap = claimValues[id],
		      let availableValues = claimValueMap[claimPath] else {
			return false
		}
		return values.contains { availableValues.contains($0) }
	}
}

struct CredentialQueryWrapper: Decodable { let credentials: [CredentialQuery] }
